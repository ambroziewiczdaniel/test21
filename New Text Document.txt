#include "systemWarehouse.h"

systemWarehouse::systemWarehouse()
{
    // Database Initialization
    db = QSqlDatabase::addDatabase("QSQLITE");
    db.setDatabaseName("database.db");
    openDatabase();

    // Inicjalizacja ProductDao po otwarciu bazy danych
    m_productDao = new ProductDao(db);

    loadProducts(); // loadProducts teraz użyje ProductDao
}

systemWarehouse::~systemWarehouse()
{
    qDeleteAll(products); // Nadal sprzątamy pamięć dla obiektów Product
    delete m_productDao; // Usuwamy instancję ProductDao
}

void systemWarehouse::loadProducts()
{
    qDeleteAll(products); // Sprzątamy poprzednie produkty
    products.clear();

    // Teraz loadProducts korzysta z ProductDao
    products = m_productDao->getAllProducts();

    qDebug() << "Zaladowano" << products.size() << "produktow ;)" << "Przez ProductDao.";
}


QString systemWarehouse::authorize_logIn(std::string username, std::string password)
{
    QString result;
    QSqlQuery query(db); // To zapytanie jest specyficzne dla autoryzacji, więc na razie zostaje tu
    query.prepare("SELECT role FROM users WHERE login = :login AND password = :password");
    query.bindValue(":login", QString::fromStdString(username));
    query.bindValue(":password", QString::fromStdString(password));

    if (query.exec()) {
        if (query.next()) {
            result = query.value("role").toString();
            Current_User = new UserClass(result);
        }
    } else {
        qDebug() << "Błąd zapytania logowania:" << query.lastError().text();
        return "";
    }

    return result;
}

// Ta metoda jest do refaktoryzacji. Docelowo nie powinna przyjmować QAbstractTableModel*,
// tylko zwracać dane (np. QVector<Product*>) lub pozwolić widokowi na bezpośrednie użycie QSqlQueryModel
// z zapytaniem z ProductDao.
void systemWarehouse::load_product_table_filtered(const QString& filterText, QAbstractTableModel* model)
{
    // Logic from here should be moved into a ProductService or directly used by the view via ProductDao
    // For now, it remains here but the goal is to remove direct SQL queries from systemWarehouse
    // and move them to ProductDao.

    auto modelSql = dynamic_cast<QSqlQueryModel*>(model);
    if (!modelSql) {
        qDebug() << "systemWarehouse: load_product_table_filtered - model nie jest QSqlQueryModel.";
        return;
    }

    QSqlQuery query(db); // Nadal używa bezpośredniego SQL, to jest punkt do poprawy
    QString baseQuery =
        "SELECT "
        "p.id, "
        "p.name, "
        "p.quantity, "
        "SUM(l.ilosc) AS total_actual_quantity, "
        "GROUP_CONCAT(l.regal || '-' || l.polka || '-' || l.kolumna || ' (Ilość: ' || l.ilosc || ')', '; ') AS locations_summary "
        "FROM products p "
        "LEFT JOIN locations l ON p.id = l.id ";

    if (filterText.isEmpty()) {
        query.prepare(baseQuery + "GROUP BY p.id, p.name, p.quantity ORDER BY p.name;");
    }
    else {
        query.prepare(baseQuery +
            "WHERE UPPER(p.name) LIKE UPPER(:filterText) "
            "GROUP BY p.id, p.name, p.quantity ORDER BY p.name;");
        query.bindValue(":filterText", "%" + filterText + "%");
    }

    QWidget* active_window = QApplication::activeWindow();

    if (!query.exec()) {
        QMessageBox::critical(active_window, "Błąd Zapytania SQL (Magazyn)",
            "Błąd podczas ładowania danych: " + query.lastError().text() + "\nZapytanie: " + query.executedQuery());
        qDebug() << "Błąd Zapytania SQL (Magazyn):" << query.lastError().text();
        qDebug() << "Zapytanie:" << query.executedQuery();
        return;
    }

    modelSql->setQuery(std::move(query));

    if (modelSql->lastError().isValid()) {
        QMessageBox::critical(active_window, "Błąd Modelu SQL (Magazyn)",
            "Błąd po ustawieniu zapytania w modelu: " + modelSql->lastError().text());
        qDebug() << "Błąd Modelu SQL (Magazyn):" << modelSql->lastError().text();
    }

    modelSql->setHeaderData(0, Qt::Horizontal, "ID Produktu");
    modelSql->setHeaderData(1, Qt::Horizontal, "Nazwa Produktu");
    modelSql->setHeaderData(2, Qt::Horizontal, QString::fromUtf8("Minimalna dopuszczalna ilosc"));
    modelSql->setHeaderData(3, Qt::Horizontal, QString::fromUtf8("Całkowita ilość w magazynie"));
    modelSql->setHeaderData(4, Qt::Horizontal, QString::fromUtf8("Lokalizacje (Regał-Półka-Kolumna, Ilosc)"));
}

bool systemWarehouse::openDatabase()
{
    if (!db.open()) {
        QWidget* active_window = QApplication::activeWindow();
        QMessageBox::critical(active_window, "Błąd Bazy Danych", "Nie można otworzyć bazy danych\n"
                                     "Upwenij się że istnieje sprawny plik: " + QDir::currentPath() + "/database.db \n");

        qDebug() << "Błąd otwarcia database.db dla logowania:" << db.lastError().text();
    } else {
        qDebug() << "Baza danych otwarta dla logowania.";
    }
    return db.isOpen();
}